# -*- coding: utf-8 -*-
"""LoanData_Statistics

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pEfsiPfWk48qT6IH9lU5qeVipSKktveG

#**Statistics Final Project - Data Analytics**
#####Seeing what a data can do from our perspective as Software Engineers

#####Glorious Satria Dhamang Aji - 1302213015 ùùã
#####Farhan Mulya Argyanto - 1302213073 ‚Ñµ

###**Import Library**
"""

install.packages("moments")
library(moments)
install.packages("psych")
library(psych)
install.packages("corrplot")
library(corrplot)
install.packages('ggplot2')
library(ggplot2)
install.packages("gridExtra")
library(gridExtra)

"""###**Data reading**"""

data <- read.csv("20 madhante.csv", sep = ";")
data$Credit_History <- as.character(data$Credit_History)
data$Loan_Amount_Term <- as.character(data$Loan_Amount_Term)
head(data)

"""##**Data Preprocessing**

###**Missing Data Handling**
"""

columns_to_check <- c("ApplicantIncome", "CoapplicantIncome", "LoanAmount", "Loan_Amount_Term", "Credit_History")
na_count_per_column <- colSums(is.na(data[, columns_to_check]))
print("--------The NA values in numerical data columns------------")
print(na_count_per_column)
cat('\n')
empty_string_count_per_column <- colSums(data[, c("Gender", "Married", "Dependents", "Education", "Self_Employed", "Property_Area")] == "")
print("--------The empty string values in categorical data columns------------")
print(empty_string_count_per_column)

"""##**Inference**
1. There are 5 Loan amount data missing
12. There are 6 Loan amount term data missing
3. There are 29 Credit History term data missing
4. There are 11 Gender data missing
5. There are 10 Dependents data missing
6. There are 23 Self Employed data missing
"""

library(dplyr)
data <- data %>%
 mutate(Gender = replace(Gender, Gender == "", NA)) %>%
 mutate(Married = replace(Married, Married == "", NA)) %>%
 mutate(Dependents = replace(Dependents, Dependents == "", NA)) %>%
 mutate(Self_Employed = replace(Self_Employed, Self_Employed == "", NA))%>%
 mutate(LoanAmount = replace(LoanAmount, LoanAmount == "", NA))
list_na <- colnames(data)[ apply(data, 2, anyNA) ]
print("Convert missing string value into NA value")
list_na

getmode <- function(v){
 v=v[nchar(as.character(v))>0]
 uniqv <- unique(v)
 uniqv[which.max(tabulate(match(v, uniqv)))]
}
data <- data %>%
mutate( LoanAmount = replace(LoanAmount, is.na(LoanAmount), mean(na.omit(data$LoanAmount))),
        Loan_Amount_Term = replace(Loan_Amount_Term, is.na(Loan_Amount_Term), getmode(Loan_Amount_Term)),
        Credit_History = replace(Credit_History, is.na(Credit_History), getmode(Credit_History)),
        Gender = replace(Gender, is.na(Gender), getmode(Gender)),
        Married = replace(Married, is.na(Married), getmode(Married)),
        Dependents = replace(Dependents, is.na(Dependents), getmode(Dependents)),
        Self_Employed = replace(Self_Employed, is.na(Self_Employed), getmode(Self_Employed)),

      )
cat("Missing data after preprocessing : ",sum(is.na(data)))

#check duplicate data
data.frame(
 row_of_data = data %>% nrow (),
 row_of_unique.data = data %>% distinct() %>% nrow()
)

"""##**Descriptive Statistics**

Raw data before preprocessing
"""

description <- describe(data)
description

"""###**Data Outlier Handling**"""

dataout <- data
outliers <- function(x) {
 Q1 <- quantile(x, probs=.25)
 Q3 <- quantile(x, probs=.75)
 iqr = Q3-Q1
 upper_limit = Q3 + (iqr*1.5)
 lower_limit = Q1 - (iqr*1.5)
 x > upper_limit | x < lower_limit
}
outlier1 <- subset(dataout, outliers(dataout$LoanAmount))
outlier2 <- subset(dataout, outliers(dataout$ApplicantIncome))
outlier3 <- subset(dataout, outliers(dataout$CoapplicantIncome))
data <- rbind(outlier1, outlier2, outlier3) %>% distinct()
head(data)

"""##**Numeric Data Separation**"""

data_num <- select_if(data, is.numeric)
head(data_num)

"""##**Categoric Data Separation**"""

data_cat <- select_if(data, is.character)
head(data_cat)

"""##**Numeric Data Handling**

###**Standarization**
"""

standar <- as.data.frame(lapply(data_num, scale))
head(standar)

"""###**Normalization**"""

# Fungsi normalisasi Min-Max
normalize <- function(x) {
 return((x- min(x))/(max(x)-min(x)))
}
normal <- as.data.frame(lapply(data_num, normalize))
head(normal)

"""##**Data Concatenation**"""

data <- cbind(data_num, data_cat)

"""The data after preprocessing"""

description <- describe(data)
description

"""##**Data Amount**"""

num_duplicated_id <- sum(duplicated(data$Loan_ID))
cat("Number of Duplicated IDs:", num_duplicated_id, "\n")
factor_property_area <- as.factor(data$Property_Area)
num_unique_categories <- nlevels(factor_property_area)
cat("Number of Property Area Category:", num_unique_categories, "\n")
unique_categories <- unique(data$Property_Area)
cat("All Unique Categories:",unique_categories)

library(dplyr)
counts <- data %>%
  summarise(
    Male = sum(Gender == "Male"),
    Female = sum(Gender == "Female"),
    Working_at_Company = sum(Self_Employed == "No"),
    Self_Employed = sum(Self_Employed == "Yes"),
    Graduate = sum(Education == "Graduate"),
    Not_graduate = sum(Education == "Not Graduate"),
    Semi_Urban = sum(Property_Area == "Semiurban"),
    Urban = sum(Property_Area == "Urban"),
    Rural = sum(Property_Area == "Rural")
  )
# Print the counts
print(counts)

# Convert categorical variables to factors with the same levels
data$Gender <- factor(data$Gender)
data$Married <- factor(data$Married)
data$Education <- factor(data$Education)
data$Property_Area <- factor(data$Property_Area)
data$Self_Employed <- factor(data$Self_Employed)
data$Dependents <- factor(data$Dependents)

# Create frequency tables for each categorical variable
Gender_freq <- table(data$Gender)
Married_freq <- table(data$Married)
Education_freq <- table(data$Education)
Property_Area_freq <- table(data$Property_Area)
SelfEmployed_freq <- table(data$Self_Employed)
Dependents_freq <- table(data$Dependents)

par(mfrow = c(2, 3))
# Define three shades of grey
grey_colors <- c("darkgrey", "lightgrey", "grey70")

# Create a bar plot for each variable with three shades of grey
barplot(Gender_freq, main = "Gender", col = grey_colors)
barplot(Married_freq, main = "Married", col = grey_colors)
barplot(Education_freq, main = "Education", col = grey_colors)
barplot(Property_Area_freq, main = "Property Area", col = grey_colors)
barplot(SelfEmployed_freq, main = "Self Employed", col = grey_colors)
barplot(Dependents_freq, main = "Dependents", col = grey_colors)

"""##**Inference**
7. Loan Applicant incomes range from 0 (no income) to 72529.
8. Loan Co-Applicant incomes range from 0 ( no - Co-Applicant) to 24000.
9. Loan Amount range from 28 to 550.
10. Loan Amount term range from 6 to 480 months.
11. All IDs are unique and randomly alloted. They have no impact on the other data and can be dropped.
12. Most Applicants are male.
13. Most Applicants are working in a company.
14. Most Applicants are Graduate.
15. The average number of loans sent was 136.6
16. The average loan repayment was 341.3 days
17. The graduate applicant and no graduate applicant have an extreme difference
18. Most applicant don't have dependents

##**Data Wrangling**
"""

data <- data[, -which(names(data) == "Loan_ID")]
head(data)

count_data_gender <- data %>%
  group_by(Gender) %>%
  summarise(count = n())

count_data_married <- data %>%
  group_by(Married) %>%
  summarise(count = n())

count_data_dependents <- data %>%
  group_by(Dependents) %>%
  summarise(count = n())

print(count_data_gender)
print(count_data_married)
print(count_data_dependents)

"""##**Data From Compound Attribute**"""

median_data_married_applicant_income <- data %>%
  group_by(Married) %>%
  summarise(median_income = median(ApplicantIncome, na.rm = TRUE))
mean_data_married_applicant_income <- data %>%
  group_by(Married) %>%
  summarise(mean_income = mean(ApplicantIncome, na.rm = TRUE))
median_data_married_coapplicant_income <- data %>%
  group_by(Married) %>%
  summarise(median_income = median(CoapplicantIncome, na.rm = TRUE))
mean_data_married_coapplicant_income <- data %>%
  group_by(Married) %>%
  summarise(mean_income = mean(CoapplicantIncome, na.rm = TRUE))

cat("----- Median and Mean Applicant Income by Marital Status -----\n")
print(median_data_married_applicant_income)
print(mean_data_married_applicant_income)

cat("\n----- Median and Mean Coapplicant Income by Marital Status -----\n")
print(median_data_married_coapplicant_income)
print(mean_data_married_coapplicant_income)

result <- data %>%
  filter(Married == "Yes") %>%
  group_by(Dependents, Education) %>%
  summarise(count = n(), .groups = 'drop')


print(result)

loan_stats <- data %>%
  group_by(Education, Property_Area) %>%
  summarise(
    median_loan_amount = median(LoanAmount, na.rm = TRUE),
    mean_loan_amount = mean(LoanAmount, na.rm = TRUE)
  )

print(loan_stats)

credit_history_stats <- data %>%
  group_by(Gender, Education) %>%
  summarise(
    good_credit_count = sum(Credit_History == 1, na.rm = TRUE),
    bad_credit_count = sum(Credit_History == 0, na.rm = TRUE)
  )

print(credit_history_stats)

"""##**Inference**
19. Most applicants with 3+ dependents are graduate people.
20. Most applicants with 2 dependents are graduate people.
21. Most applicant with 1 dependents are graduate people.
22. Most applicants that have good credit history are Graduate Male.
23. Most applicants that have bad credit history are also Graduate Male.
24. Most applicant with marital status have more income.
25. Most cases of applicant with no co-applicants are not married.
26. Applicants that are Graduate people from Rural place have the highest mean of Loan Amount.
27. Applicants that are No Graduate people from Semiurban place have the highest mean of Loan Amount

###**Data Visualization**
"""

# Install and load required libraries
library(vcd)
library(viridis)
library(gplots)

numeric_vars <- data[, c("ApplicantIncome", "CoapplicantIncome", "LoanAmount")]
categorical_vars <- data[, c("Gender", "Married")]

# Calculate Pearson correlation coefficients for numeric variables
pearson_corr_matrix <- cor(numeric_vars)

# Calculate Cram√©r's V for categorical variables
cramer_v_matrix <- matrix(NA, nrow = ncol(categorical_vars), ncol = ncol(categorical_vars))
for (i in 1:(ncol(categorical_vars) - 1)) {
  for (j in (i + 1):ncol(categorical_vars)) {
    contingency_table <- table(categorical_vars[, i], categorical_vars[, j])
    cramer_v_matrix[i, j] <- assocstats(contingency_table)$cramer
    cramer_v_matrix[j, i] <- cramer_v_matrix[i, j]
  }
}

# Number of numeric and categorical variables
num_numeric_vars <- ncol(numeric_vars)
num_categorical_vars <- ncol(categorical_vars)

# Combine the matrices
composite_corr_matrix <- matrix(NA, nrow = num_numeric_vars + num_categorical_vars, ncol = num_numeric_vars + num_categorical_vars)

# Fill in the Pearson correlation coefficients
composite_corr_matrix[1:num_numeric_vars, 1:num_numeric_vars] <- pearson_corr_matrix

# Fill in the Cram√©r's V values
composite_corr_matrix[(num_numeric_vars + 1):(num_numeric_vars + num_categorical_vars), (num_numeric_vars + 1):(num_numeric_vars + num_categorical_vars)] <- cramer_v_matrix

# Replace missing or infinite values with 0
composite_corr_matrix[is.na(composite_corr_matrix) | is.infinite(composite_corr_matrix)] <- 0

# Row and column names
rownames(composite_corr_matrix) <- colnames(composite_corr_matrix) <- c(names(numeric_vars), names(categorical_vars))
canvas_width <- 10
canvas_height <- 6
# Create a heatmap with heatmap.2
heatmap.2(
  composite_corr_matrix,
  col = viridis(10),
  main = "Composite Correlation Heatmap",
  margins = c(5, 5),
  labRow = rownames(composite_corr_matrix),  # Use variable names for row labels
  labCol = colnames(composite_corr_matrix),  # Use variable names for column labels
  cexRow = 1.0,
  cexCol = 1.0,
  trace = "none",  # Remove dendrogram traces
  key.title = "Correlation",
  key.xlab = "Value",
  key.ylab = NULL,
  width = canvas_width,
  height = canvas_height
)

a1 <- ggplot(data,aes(x = Dependents, y = Education, fill = data$ApplicantIncome)) + geom_tile() + scale_fill_distiller(palette = "Spectral") + ggtitle("Madhante Loan")
a2 <- ggplot(data,aes(x = Dependents, y = Education, fill = data$ApplicantIncome)) + geom_tile() + scale_fill_distiller(palette = "Spectral") + ggtitle("Madhante Loan")
a3 <- ggplot(data,aes(x = Dependents, y = Education, fill = LoanAmount)) + geom_tile() + scale_fill_distiller(palette = "Spectral") + ggtitle("Madhante Loan")
a4 <- ggplot(data,aes(x = Dependents, y = Education, fill = Loan_Amount_Term)) + geom_tile() + scale_fill_distiller(palette = "Spectral") + ggtitle("Madhante Loan")
a5 <- ggplot(data,aes(x = Dependents, y = Education, fill = Credit_History)) + geom_tile() + scale_fill_distiller(palette = "Spectral") + ggtitle("Madhante Loan")
gridExtra::grid.arrange(a1,a2,a3,a4,a5,nrow = 5)

"""##**Inference**

27. People who have graduated in education and earn a greater income than people who have not graduated, are given larger loans but are given less time to repay the loan.
28. people who have more dependents are given more loans, but the repayment time is longer than those who have fewer dependents.
"""

plot(data$ApplicantIncome, type="o", col="red", main="Line Diagram")
lines(data$CoapplicantIncome, type="o", col ="blue")
lines(data$LoanAmount, type="o", col ="yellow")
lines(data$Loan_Amount_Term, type="o", col ="brown")
lines(data$Credit_History, type="o", col ="green")

"""##**Inference**
29. Applicant Income data has an extreme range
30. Coapplicant Income data has an extreme range
"""

plot(data)

plot(data$LoanAmount, data$ApplicantIncome, type='p', col= c('red', 'blue'))
points(data$LoanAmount, data$Loan_Amount_Term,col =c('aquamarine1', 'darkorange'))

plot(data$LoanAmount, data$CoapplicantIncome, type='p', col= c('red', 'blue'))
points(data$LoanAmount, data$Credit_History,col =c('aquamarine1', 'darkorange'))

plot(data$LoanAmount, data$ApplicantIncome, type='p', col= c('red', 'blue'))
points(data$LoanAmount, data$Loan_Amount_Term,col =c('aquamarine1', 'darkorange'))

plot(data$LoanAmount, data$ApplicantIncome, type='p', col= c('red', 'blue'))
points(data$LoanAmount, data$Loan_Amount_Term,col =c('aquamarine1', 'darkorange'))

plot(data$Gender, data$ApplicantIncome, type='p', col= c('red', 'blue'))
points(data$Gender, data$Loan_Amount_Term,col =c('aquamarine1', 'darkorange'))

plot(data$LoanAmount, data$ApplicantIncome, type='l', col= c('red'))

matriks = cbind(data$ApplicantIncome,data$LoanAmount,data$Loan_Amount_Term,data$Credit_History)
cor(matriks,use = "complete.obs")

"""##**Uji Hipotesis**"""

